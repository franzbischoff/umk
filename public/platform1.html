<html>
  <head>
    <title>Hello, World! example for mxGraph</title>

    <!-- Sets the basepath for the library if not in same directory -->
    <script type="text/javascript">
      mxBasePath = "/javascript/src";
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <!-- Loads and initializes the library -->
    <script
      type="text/javascript"
      src="/javascript/src/js/mxClient.js"
    ></script>
    <link rel="stylesheet" href="/css/notyf.min.css" />
    <script src="/js/notyf.min.js"></script>

    <!-- Example code -->
    <script type="text/javascript">
      var graph;
      var editor;
      var tempVar;

      function main(container, outline) {
        // Checks if the browser is supported
        if (!mxClient.isBrowserSupported()) {
          mxUtils.error("Browser is not supported!", 200, false);
        } else {
          //Initializing global settings
          mxGraphHandler.prototype.guidesEnabled = true;
          mxGraphHandler.prototype.useGuidesForEvent = function(me) {
            return !mxEvent.isAltDown(me.getEvent());
          };
          mxConstants.GUIDE_COLOR = "#FF0000";
          mxConstants.GUIDE_STROKEWIDTH = 1;
          mxConstants.WORD_WRAP = "break-word";
          mxConstants.SHADOW_OFFSET_X = 5;
          mxConstants.SHADOW_OFFSET_Y = 5;
          mxConstants.SHADOW_OPACITY = 0.2;
          mxEdgeHandler.prototype.snapToTerminals = true;
          mxConnectionHandler.prototype.movePreviewAway = false;
          mxClient.NO_FO = mxClient.NO_FO || mxClient.IS_SF || mxClient.IS_GC;
          graph = new mxGraph(container);
          graph.setTooltips(false);
          graph.htmlLabels = true;
          graph.setConnectable(true);
          graph.setAllowDanglingEdges(false);
          var vStyle = graph.getStylesheet().getDefaultVertexStyle();
          var eStyle = graph.getStylesheet().getDefaultEdgeStyle();
          vStyle["shadow"] = true;
          vStyle["whiteSpace"] = "wrap";
          vStyle["arcSize"] = 10;
          vStyle["absoluteArcSize"] = 1;
          vStyle["rounded"] = 1;
          eStyle["edgeStyle"] = "orthogonalEdgeStyle";
          new mxRubberband(graph);
          var keyHandler = new mxKeyHandler(graph);
          var parent = graph.getDefaultParent();
          var outln = new mxOutline(graph, outline);
          /*graph.autoSizeCellsOnAdd = true;
graph.autoSizeCells = true;/**/
          //Copy Paste of blocks
          graph.cloneCells = function(
            cells,
            allowInvalidEdges,
            mapping,
            keepPosition
          ) {
            customValidationError = false;
            var out = mxGraph.prototype.cloneCells.apply(this, arguments);
            customValidationError = true;
            return out;
          };
          mxClipboard.cellsToString = function(cells) {
            var codec = new mxCodec();
            var model = new mxGraphModel();
            var parent = model.getChildAt(model.getRoot(), 0);
            for (var i = 0; i < cells.length; i++) {
              model.add(parent, cells[i]);
            }
            return mxUtils.getXml(codec.encode(model));
          };
          var textInput = document.createElement("textarea");
          mxUtils.setOpacity(textInput, 0);
          textInput.style.width = "1px";
          textInput.style.height = "1px";
          var restoreFocus = false;
          var gs = graph.gridSize;
          var lastPaste = null;
          var dx = 0;
          var dy = 0;
          textInput.value = " ";
          mxEvent.addListener(document, "keydown", function(evt) {
            var source = mxEvent.getSource(evt);
            if (
              graph.isEnabled() &&
              !graph.isMouseDown &&
              !graph.isEditing() &&
              source.nodeName != "INPUT"
            ) {
              if (
                evt.keyCode == 224 ||
                (!mxClient.IS_MAC && evt.keyCode == 17) ||
                (mxClient.IS_MAC && evt.keyCode == 91)
              ) {
                if (!restoreFocus) {
                  textInput.style.position = "absolute";
                  textInput.style.left = graph.container.scrollLeft + 10 + "px";
                  textInput.style.top = graph.container.scrollTop + 10 + "px";
                  graph.container.appendChild(textInput);
                  restoreFocus = true;
                  textInput.focus();
                  textInput.select();
                }
              }
            }
          });
          mxEvent.addListener(document, "keyup", function(evt) {
            if (
              restoreFocus &&
              (evt.keyCode == 224 || evt.keyCode == 17 || evt.keyCode == 91)
            ) {
              restoreFocus = false;
              if (!graph.isEditing()) {
                graph.container.focus();
              }
              textInput.parentNode.removeChild(textInput);
            }
          });
          var copyCells = function(graph, cells) {
            if (cells.length > 0) {
              var clones = graph.cloneCells(cells);
              for (var i = 0; i < clones.length; i++) {
                var state = graph.view.getState(cells[i]);
                if (state != null) {
                  var geo = graph.getCellGeometry(clones[i]);
                  if (geo != null && geo.relative) {
                    geo.relative = false;
                    geo.x = state.x / state.view.scale - state.view.translate.x;
                    geo.y = state.y / state.view.scale - state.view.translate.y;
                  }
                }
              }
              textInput.value = mxClipboard.cellsToString(clones);
            }
            textInput.select();
            lastPaste = textInput.value;
          };
          mxEvent.addListener(
            textInput,
            "copy",
            mxUtils.bind(this, function(evt) {
              if (graph.isEnabled() && !graph.isSelectionEmpty()) {
                copyCells(
                  graph,
                  mxUtils.sortCells(
                    graph.model.getTopmostCells(graph.getSelectionCells())
                  )
                );
                dx = 0;
                dy = 0;
              }
            })
          );
          mxEvent.addListener(
            textInput,
            "cut",
            mxUtils.bind(this, function(evt) {
              if (graph.isEnabled() && !graph.isSelectionEmpty()) {
                copyCells(graph, graph.removeCells());
                dx = -gs;
                dy = -gs;
              }
            })
          );
          var importXml = function(xml, dx, dy) {
            dx = dx != null ? dx : 0;
            dy = dy != null ? dy : 0;
            var cells = [];
            try {
              var doc = mxUtils.parseXml(xml);
              var node = doc.documentElement;
              if (node != null) {
                var model = new mxGraphModel();
                var codec = new mxCodec(node.ownerDocument);
                codec.decode(node, model);
                var childCount = model.getChildCount(model.getRoot());
                var targetChildCount = graph.model.getChildCount(
                  graph.model.getRoot()
                );
                graph.model.beginUpdate();
                try {
                  for (var i = 0; i < childCount; i++) {
                    var parent = model.getChildAt(model.getRoot(), i);
                    if (targetChildCount > i) {
                      var target =
                        childCount == 1
                          ? graph.getDefaultParent()
                          : graph.model.getChildAt(graph.model.getRoot(), i);
                      if (!graph.isCellLocked(target)) {
                        var children = model.getChildren(parent);
                        cells = cells.concat(
                          graph.importCells(children, dx, dy, target)
                        );
                      }
                    } else {
                      parent = graph.importCells(
                        [parent],
                        0,
                        0,
                        graph.model.getRoot()
                      )[0];
                      var children = graph.model.getChildren(parent);
                      graph.moveCells(children, dx, dy);
                      cells = cells.concat(children);
                    }
                  }
                } finally {
                  graph.model.endUpdate();
                }
              }
            } catch (e) {
              alert(e);
              throw e;
            }
            return cells;
          };
          var pasteText = function(text) {
            var xml = mxUtils.trim(text);
            var x =
              graph.container.scrollLeft / graph.view.scale -
              graph.view.translate.x;
            var y =
              graph.container.scrollTop / graph.view.scale -
              graph.view.translate.y;
            if (xml.length > 0) {
              if (lastPaste != xml) {
                lastPaste = xml;
                dx = 0;
                dy = 0;
              } else {
                dx += gs;
                dy += gs;
              }
              if (xml.substring(0, 14) == "<mxGraphModel>") {
                graph.setSelectionCells(importXml(xml, dx, dy));
                graph.scrollCellToVisible(graph.getSelectionCell());
              }
            }
          };
          var extractGraphModelFromEvent = function(evt) {
            var data = null;
            if (evt != null) {
              var provider =
                evt.dataTransfer != null ? evt.dataTransfer : evt.clipboardData;
              if (provider != null) {
                if (
                  document.documentMode == 10 ||
                  document.documentMode == 11
                ) {
                  data = provider.getData("Text");
                } else {
                  data =
                    mxUtils.indexOf(provider.types, "text/html") >= 0
                      ? provider.getData("text/html")
                      : null;
                  if (
                    mxUtils.indexOf(
                      provider.types,
                      "text/plain" && (data == null || data.length == 0)
                    )
                  ) {
                    data = provider.getData("text/plain");
                  }
                }
              }
            }
            return data;
          };
          mxEvent.addListener(textInput, "paste", function(evt) {
            textInput.value = "";
            if (graph.isEnabled()) {
              var xml = extractGraphModelFromEvent(evt);
              if (xml != null && xml.length > 0) {
                pasteText(xml);
              } else {
                window.setTimeout(
                  mxUtils.bind(this, function() {
                    pasteText(textInput.value);
                  }),
                  0
                );
              }
            }
            textInput.select();
          });
          //delete blocks
          keyHandler.bindKey(46, function(evt) {
            if (graph.isEnabled()) {
              graph.removeCells();
            }
          });
          //Lines before connecting edges
          graph.view.updateFixedTerminalPoint = function(
            edge,
            terminal,
            source,
            constraint
          ) {
            mxGraphView.prototype.updateFixedTerminalPoint.apply(
              this,
              arguments
            );
            var pts = edge.absolutePoints;
            var pt = pts[source ? 0 : pts.length - 1];
            if (
              terminal != null &&
              pt == null &&
              this.getPerimeterFunction(terminal) == null
            ) {
              edge.setAbsoluteTerminalPoint(
                new mxPoint(
                  this.getRoutingCenterX(terminal),
                  this.getRoutingCenterY(terminal)
                ),
                source
              );
            }
          };
          graph.connectionHandler.createEdgeState = function(me) {
            var edge = graph.createEdge(null, null, null, null, null);
            return new mxCellState(
              this.graph.view,
              edge,
              this.graph.getCellStyle(edge)
            );
          };
          //Custom Grid
          (function() {
            try {
              var canvas = document.createElement("canvas");
              canvas.style.position = "absolute";
              canvas.style.top = "0px";
              canvas.style.left = "0px";
              canvas.style.zIndex = -1;
              graph.container.appendChild(canvas);
              var ctx = canvas.getContext("2d");
              var mxGraphViewIsContainerEvent =
                mxGraphView.prototype.isContainerEvent;
              mxGraphView.prototype.isContainerEvent = function(evt) {
                return (
                  mxGraphViewIsContainerEvent.apply(this, arguments) ||
                  mxEvent.getSource(evt) == canvas
                );
              };
              var s = 0;
              var gs = 0;
              var tr = new mxPoint();
              var w = 0;
              var h = 0;
              repaintGrid();
              function repaintGrid() {
                if (ctx != null) {
                  var bounds = graph.getGraphBounds();
                  var width = Math.max(
                    bounds.x + bounds.width,
                    graph.container.clientWidth
                  );
                  var height = Math.max(
                    bounds.y + bounds.height,
                    graph.container.clientHeight
                  );
                  var sizeChanged = width != w || height != h;
                  if (
                    graph.view.scale != s ||
                    graph.view.translate.x != tr.x ||
                    graph.view.translate.y != tr.y ||
                    gs != graph.gridSize ||
                    sizeChanged
                  ) {
                    tr = graph.view.translate.clone();
                    s = graph.view.scale;
                    gs = graph.gridSize;
                    w = width;
                    h = height;
                    if (!sizeChanged) {
                      ctx.clearRect(0, 0, w, h);
                    } else {
                      canvas.setAttribute("width", w);
                      canvas.setAttribute("height", h);
                    }
                    var tx = tr.x * s;
                    var ty = tr.y * s;
                    var minStepping = graph.gridSize;
                    var stepping = minStepping * s;
                    if (stepping < minStepping) {
                      var count =
                        Math.round(Math.ceil(minStepping / stepping) / 2) * 2;
                      stepping = count * stepping;
                    }
                    var xs = Math.floor((0 - tx) / stepping) * stepping + tx;
                    var xe = Math.ceil(w / stepping) * stepping;
                    var ys = Math.floor((0 - ty) / stepping) * stepping + ty;
                    var ye = Math.ceil(h / stepping) * stepping;
                    xe += Math.ceil(stepping);
                    ye += Math.ceil(stepping);
                    var ixs = Math.round(xs);
                    var ixe = Math.round(xe);
                    var iys = Math.round(ys);
                    var iye = Math.round(ye);
                    ctx.strokeStyle = "#f0f0f0";
                    ctx.fillStyle = "#fefefe";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.beginPath();
                    ctx.lineWidth = 0.5;
                    for (var x = xs; x <= xe; x += stepping) {
                      x = Math.round((x - tx) / stepping) * stepping + tx;
                      var ix = Math.round(x);
                      ctx.moveTo(ix + 0.5, iys + 0.5);
                      ctx.lineTo(ix + 0.5, iye + 0.5);
                    }
                    for (var y = ys; y <= ye; y += stepping) {
                      y = Math.round((y - ty) / stepping) * stepping + ty;
                      var iy = Math.round(y);
                      ctx.moveTo(ixs + 0.5, iy + 0.5);
                      ctx.lineTo(ixe + 0.5, iy + 0.5);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    for (var x = xs; x <= xe; x += 5 * stepping) {
                      x = Math.round((x - tx) / stepping) * stepping + tx;
                      var ix = Math.round(x);
                      ctx.moveTo(ix + 0.5, iys + 0.5);
                      ctx.lineTo(ix + 0.5, iye + 0.5);
                    }
                    for (var y = ys; y <= ye; y += 5 * stepping) {
                      y = Math.round((y - ty) / stepping) * stepping + ty;
                      var iy = Math.round(y);
                      ctx.moveTo(ixs + 0.5, iy + 0.5);
                      ctx.lineTo(ixe + 0.5, iy + 0.5);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.lineWidth = 1.5;
                    for (var x = xs; x <= xe; x += 10 * stepping) {
                      x = Math.round((x - tx) / stepping) * stepping + tx;
                      var ix = Math.round(x);
                      ctx.moveTo(ix + 0.5, iys + 0.5);
                      ctx.lineTo(ix + 0.5, iye + 0.5);
                    }
                    for (var y = ys; y <= ye; y += 10 * stepping) {
                      y = Math.round((y - ty) / stepping) * stepping + ty;
                      var iy = Math.round(y);
                      ctx.moveTo(ixs + 0.5, iy + 0.5);
                      ctx.lineTo(ixe + 0.5, iy + 0.5);
                    }
                    ctx.closePath();
                    ctx.stroke();
                  }
                }
              }
            } catch (e) {
              mxLog.show();
              mxLog.debug("Using background image");
              container.style.backgroundImage = "url('/images/grid.gif')";
            }
            var mxGraphViewValidateBackground =
              mxGraphView.prototype.validateBackground;
            mxGraphView.prototype.validateBackground = function() {
              mxGraphViewValidateBackground.apply(this, arguments);
              try {
                repaintGrid();
              } catch (e) {}
              MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
            };
          })();
          //Connection validation
          var customValidationError = true;
          var default_getEdgeValidationError =
            mxGraph.prototype.getEdgeValidationError;
          mxGraph.prototype.getEdgeValidationError = function(
            edge,
            source,
            target
          ) {
            console.log(source.edges);
            var defaultOut = default_getEdgeValidationError.apply(
              this,
              arguments
            );
            if (customValidationError) {
              if (defaultOut !== null) {
                return defaultOut;
              } else {
                var outError;
                if (source.parent === target.parent)
                  outError = "Cannot connect to the same block.";
                if (source.geometry.x == 0)
                  outError = "Tapping input port is not allowed.";
                if (target.geometry.x == 1)
                  outError = "You cannot feed signal to the output.";
                if (!!target.edges)
                  outError = "Only one input is allowed per port.";
                console.log(outError);
                return outError;
              }
            } else return defaultOut;
          };
          mxGraph.prototype.validationAlert = function(message) {
            notyf.error(message);
          };

          //Start of initial model
          graph.getModel().beginUpdate();
          try {
            var v1 = graph.insertVertex(
              parent,
              null,
              "Hello",
              100,
              100,
              200,
              100,
              "strokeColor=blue;fillColor=red;fontColor=white;fontStyle=1;fontSize=15;verticalAlign=top;strokeWidth=3"
            );
            v1.setConnectable(false);
            var p1 = graph.insertVertex(
              v1,
              null,
              "$u_{555}(t)$",
              0,
              0.5,
              14,
              14,
              "strokeColor=blue;fillColor=red;strokeWidth=3;labelPosition=right;labelWidth=80;align=left;shape=ellipse;portConstraint=west;shadow=0",
              true
            );
            var p2 = graph.insertVertex(
              v1,
              null,
              "$y_1(t)$",
              1,
              0.5,
              14,
              14,
              "strokeColor=blue;fillColor=red;strokeWidth=3;labelPosition=left;labelWidth=80;align=right;shape=ellipse;portConstraint=east;shadow=0",
              true
            );
            p1.geometry.offset = new mxPoint(-14, -7);
            p2.geometry.offset = new mxPoint(-0, -7);
            var Details = graph.insertVertex(
              v1,
              null,
              "asdfkaj fkajh klajhf kajdshf",
              0.5,
              0,
              0,
              0,
              "fontColor=white",
              true
            );
            Details.geometry.offset = new mxPoint(0, 30);
            Details.setConnectable(false);
            var v2 = graph.insertVertex(
              parent,
              null,
              "hiasd dsf",
              200,
              200,
              300,
              100,
              "verticalAlign=top"
            );
            v2.setConnectable(false);
            var p1 = graph.insertVertex(
              v2,
              null,
              "$u_1(t)$",
              0,
              0.5,
              50,
              20,
              "portConstraint=west;shadow=0",
              true
            );
            var p2 = graph.insertVertex(
              v2,
              null,
              "$y_1(t)$",
              1,
              0.5,
              50,
              20,
              "portConstraint=east;shadow=0",
              true
            );
            p1.geometry.offset = new mxPoint(-25, -10);
            p2.geometry.offset = new mxPoint(-25, -10);
            var Details = graph.insertVertex(
              v2,
              null,
              "asdfkaj fkajh klajhf kajdshf",
              0.5,
              0,
              0,
              0,
              "",
              true
            );
            Details.geometry.offset = new mxPoint(0, 20);
            Details.setConnectable(false);
            var v3 = graph.insertVertex(
              parent,
              null,
              "hiasd dsf",
              40,
              200,
              300,
              100,
              "verticalAlign=top"
            );
            v3.setConnectable(false);
            var p1 = graph.insertVertex(
              v3,
              null,
              "$u_1(t)$",
              0,
              0.5,
              50,
              20,
              "portConstraint=west;shadow=0",
              true
            );
            var p2 = graph.insertVertex(
              v3,
              null,
              "$y_1(t)$",
              1,
              0.5,
              50,
              20,
              "portConstraint=east;shadow=0",
              true
            );
            p1.geometry.offset = new mxPoint(-25, -10);
            p2.geometry.offset = new mxPoint(-25, -10);
            var Details = graph.insertVertex(
              v3,
              null,
              "asdfkaj fkajh klajhf kajdshf",
              0.5,
              0,
              0,
              0,
              "",
              true
            );
            Details.geometry.offset = new mxPoint(0, 20);
            Details.setConnectable(false);
          } finally {
            graph.getModel().endUpdate();
          }
        }
      }
      // Touch screen
      (function() {
        // Enables rotation handle
        mxVertexHandler.prototype.rotationEnabled = true;

        // Enables managing of sizers
        mxVertexHandler.prototype.manageSizers = true;

        // Enables live preview
        mxVertexHandler.prototype.livePreview = true;

        // Sets constants for touch style
        mxConstants.HANDLE_SIZE = 16;
        mxConstants.LABEL_HANDLE_SIZE = 7;

        // Larger tolerance and grid for real touch devices
        if (
          mxClient.IS_TOUCH ||
          navigator.maxTouchPoints > 0 ||
          navigator.msMaxTouchPoints > 0
        ) {
          mxShape.prototype.svgStrokeTolerance = 18;
          mxVertexHandler.prototype.tolerance = 12;
          mxEdgeHandler.prototype.tolerance = 12;
          mxGraph.prototype.tolerance = 12;
        }

        // One finger pans (no rubberband selection) must start regardless of mouse button
        mxPanningHandler.prototype.isPanningTrigger = function(me) {
          var evt = me.getEvent();

          return (
            (me.getState() == null && !mxEvent.isMouseEvent(evt)) ||
            (mxEvent.isPopupTrigger(evt) &&
              (me.getState() == null ||
                mxEvent.isControlDown(evt) ||
                mxEvent.isShiftDown(evt)))
          );
        };

        // Don't clear selection if multiple cells selected
        var graphHandlerMouseDown = mxGraphHandler.prototype.mouseDown;
        mxGraphHandler.prototype.mouseDown = function(sender, me) {
          graphHandlerMouseDown.apply(this, arguments);

          if (
            this.graph.isCellSelected(me.getCell()) &&
            this.graph.getSelectionCount() > 1
          ) {
            this.delayedSelection = false;
          }
        };

        // On connect the target is selected and we clone the cell of the preview edge for insert
        mxConnectionHandler.prototype.selectCells = function(edge, target) {
          if (target != null) {
            this.graph.setSelectionCell(target);
          } else {
            this.graph.setSelectionCell(edge);
          }
        };

        // Overrides double click handling to use the tolerance
        var graphDblClick = mxGraph.prototype.dblClick;
        mxGraph.prototype.dblClick = function(evt, cell) {
          if (cell == null) {
            var pt = mxUtils.convertPoint(
              this.container,
              mxEvent.getClientX(evt),
              mxEvent.getClientY(evt)
            );
            cell = this.getCellAt(pt.x, pt.y);
          }

          graphDblClick.call(this, evt, cell);
        };

        // Rounded edge and vertex handles
        var touchHandle = new mxImage("images/handle-main.png", 17, 17);
        mxVertexHandler.prototype.handleImage = touchHandle;
        mxEdgeHandler.prototype.handleImage = touchHandle;
        mxOutline.prototype.sizerImage = touchHandle;

        mxVertexHandler.prototype.rotationHandleVSpacing = -30;
        // Pre-fetches touch handle
        new Image().src = touchHandle.src;

        // Adds connect icon to selected vertex
        var connectorSrc = "images/handle-connect.png";

        var vertexHandlerInit = mxVertexHandler.prototype.init;
        mxVertexHandler.prototype.init = function() {
          // TODO: Use 4 sizers, move outside of shape
          //this.singleSizer = this.state.width < 30 && this.state.height < 30;
          vertexHandlerInit.apply(this, arguments);

          // Only show connector image on one cell and do not show on containers
          if (
            this.graph.connectionHandler.isEnabled() &&
            this.graph.isCellConnectable(this.state.cell) &&
            this.graph.getSelectionCount() == 1
          ) {
            this.connectorImg = mxUtils.createImage(connectorSrc);
            this.connectorImg.style.cursor = "pointer";
            this.connectorImg.style.width = "29px";
            this.connectorImg.style.height = "29px";
            this.connectorImg.style.position = "absolute";

            if (!mxClient.IS_TOUCH) {
              this.connectorImg.setAttribute(
                "title",
                mxResources.get("connect")
              );
              mxEvent.redirectMouseEvents(
                this.connectorImg,
                this.graph,
                this.state
              );
            }

            // Starts connecting on touch/mouse down
            mxEvent.addGestureListeners(
              this.connectorImg,
              mxUtils.bind(this, function(evt) {
                this.graph.popupMenuHandler.hideMenu();
                this.graph.stopEditing(false);

                var pt = mxUtils.convertPoint(
                  this.graph.container,
                  mxEvent.getClientX(evt),
                  mxEvent.getClientY(evt)
                );
                this.graph.connectionHandler.start(this.state, pt.x, pt.y);
                this.graph.isMouseDown = true;
                this.graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
                mxEvent.consume(evt);
              })
            );

            this.graph.container.appendChild(this.connectorImg);
          }

          this.redrawHandles();
        };

        var vertexHandlerHideSizers = mxVertexHandler.prototype.hideSizers;
        mxVertexHandler.prototype.hideSizers = function() {
          vertexHandlerHideSizers.apply(this, arguments);

          if (this.connectorImg != null) {
            this.connectorImg.style.visibility = "hidden";
          }
        };

        var vertexHandlerReset = mxVertexHandler.prototype.reset;
        mxVertexHandler.prototype.reset = function() {
          vertexHandlerReset.apply(this, arguments);

          if (this.connectorImg != null) {
            this.connectorImg.style.visibility = "";
          }
        };

        var vertexHandlerRedrawHandles =
          mxVertexHandler.prototype.redrawHandles;
        mxVertexHandler.prototype.redrawHandles = function() {
          vertexHandlerRedrawHandles.apply(this);

          if (this.state != null && this.connectorImg != null) {
            var pt = new mxPoint();
            var s = this.state;

            // Top right for single-sizer
            if (mxVertexHandler.prototype.singleSizer) {
              pt.x = s.x + s.width - this.connectorImg.offsetWidth / 2;
              pt.y = s.y - this.connectorImg.offsetHeight / 2;
            } else {
              pt.x =
                s.x +
                s.width +
                mxConstants.HANDLE_SIZE / 2 +
                4 +
                this.connectorImg.offsetWidth / 2;
              pt.y = s.y + s.height / 2;
            }

            var alpha = mxUtils.toRadians(
              mxUtils.getValue(s.style, mxConstants.STYLE_ROTATION, 0)
            );

            if (alpha != 0) {
              var cos = Math.cos(alpha);
              var sin = Math.sin(alpha);

              var ct = new mxPoint(s.getCenterX(), s.getCenterY());
              pt = mxUtils.getRotatedPoint(pt, cos, sin, ct);
            }

            this.connectorImg.style.left =
              pt.x - this.connectorImg.offsetWidth / 2 + "px";
            this.connectorImg.style.top =
              pt.y - this.connectorImg.offsetHeight / 2 + "px";
          }
        };

        var vertexHandlerDestroy = mxVertexHandler.prototype.destroy;
        mxVertexHandler.prototype.destroy = function(sender, me) {
          vertexHandlerDestroy.apply(this, arguments);

          if (this.connectorImg != null) {
            this.connectorImg.parentNode.removeChild(this.connectorImg);
            this.connectorImg = null;
          }
        };

        // Pre-fetches touch connector
        new Image().src = connectorSrc;
      })();
    </script>
    <script></script>
  </head>

  <!-- Page passes the container for the graph to the program -->
  <body
    onload="main(document.getElementById('graphContainer'), document.getElementById('outlineContainer'))"
    style="margin: 0; padding: 0;"
  >
    <!-- Creates a container for the graph with a grid wallpaper -->
    <div
      id="graphContainer"
      style="overflow:hidden;width:100%;height:100%;"
    ></div>
    <div
      id="outlineContainer"
      class="w3-hide-small w3-hide-medium"
      style="position:absolute;overflow:hidden;top:36px;right:0px;width:200px;height:140px;background:transparent;border-style:solid;border-color:black;"
    ></div>
    <script>
      MathJax.Hub.Config({
        messageStyle: "none",
        menuSettings: {
          inTabOrder: false
        },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          preview: "none",
          inlineMath: [["$", "$"], ["\\(", "\\)"]],
          displayMath: [["$$", "$$"], ["\\[", "\\]"]]
        }
      });
    </script>
    <script>
      var notyf = new Notyf({ duration: 10000 });
    </script>
  </body>
</html>
